name: transcendence

services:
  api_gateway:
    container_name: api_gateway
    build: ./containers/api_gateway
    networks:
      - main
    depends_on:
      - user-service
      - auth-service
  #    - game_history-service
    restart: always

# USER MICROSERVICE
  user-service:
    container_name: user-service
    build: 
      context: ./containers/user/user-service
      dockerfile: Dockerfile.prod
    volumes:
      - user_uploads_volume:/uploads/avatars
    env_file:
      - .user_env
    networks:
      - main
    restart: always
    depends_on:
      user-db:
        condition: service_healthy

  user-db:
    container_name: user-db
    build: ./containers/user/user-db
    
    env_file:
      - .userdb_env
    # las variables en este archivo seran utilizadas por el contenedor user-db
    
    #environment:
      #MARIADB_PASSWORD: "userpassword"
    # las variables aqui son usadas tmb por el docker-compose, pero no te puedes fiar del rden si luego la quieres usar en un healthcheck
    # docker solo a√±ade los archivos estrictamente llamados ".env" para resolver variables del docker-compose

    volumes:
    - db_volume:/var/lib/mysql

    healthcheck:
      test: ["CMD", "healthcheck.sh", "--connect", "--innodb_initialized"]
      #test:
      # [
      #   "CMD-SHELL",
      #   "mariadb -u ${MARIADB_USER} -p${MARIADB_PASSWORD} -e 'SELECT 1'"
      # ]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 15s
    networks:
      - main
    restart: always

# AUTH MICROSERVICE
  auth-service:
    container_name: auth-service
    build: 
      context: ./containers/auth/auth-service
      dockerfile: Dockerfile.prod
    env_file:
      - ./containers/auth/auth-service/.auth_env
    networks:
      - main
    restart: always

# GAME HISTORY MICROSERVICE
#  game_history-service:
#    container_name: game_history-service
#    build: 
#      context: ./containers/game_history/game_history-service
#      dockerfile: Dockerfile.prod
#    networks:
#      - main
#    restart: always

volumes:
  db_volume:
    driver: local
  # lo vemos al hacer "docker volume ls" pero no vemos lo que se va guardando en run time en el host

  user_uploads_volume:
    driver: local
  #  driver_opts:
  #    type: none
  #    o: bind
  #    device: ./containers/user/user-service/user_uploads/avatars
  # esto seria para hacer named volumes stored as bind mounts, como en inception

networks:
   main:
     driver: bridge
